<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 深入 async functions · 42</title><meta name="description" content="深入 async functions - 42"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/sasha.css"><link rel="search" type="application/opensearchdescription+xml" href="https://42things.com/atom.xml" title="42"></head><body><div class="wrap"><header><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">深入 async functions</h1><h3 class="post-info">Nov 11, 2018</h3><div class="post-content"><p>本文主要阐述了在 Javascript 中 <code>async</code> 函数的相关特性和运行机制，及 V8 引擎如何对异步函数进行优化。</p>
<h2 id="async-function-的实现"><a href="#async-function-的实现" class="headerlink" title="async function 的实现"></a>async function 的实现</h2><p><code>async</code> 函数本质是一个自带 runner 的 <code>Generator</code> 函数。我们可以使用 <code>Generator</code> 和 <code>Promise</code> 的特性简单实现一个 <code>async</code> 函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spawn</span>(<span class="params">generatorFunc</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> iterator = generatorFunc();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">nextFunc</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> next;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        next = nextFunc();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(err);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (next.done) &#123;</span><br><span class="line">        <span class="keyword">return</span> resolve(next.value);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">Promise</span>.resolve(next.value).then(</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">          step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> iterator.next(v);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">          step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> iterator.throw(e);</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> iterator.next(<span class="literal">undefined</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sleep = <span class="function">(<span class="params">ms = <span class="number">1000</span></span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(resolve, ms));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> sleep();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">yield</span> sleep();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">yield</span> sleep();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spawn(init);</span><br></pre></td></tr></table></figure>
<h2 id="async-function-constructor"><a href="#async-function-constructor" class="headerlink" title="async function constructor"></a>async function constructor</h2><p>除了传统的函数声明和函数表达式，也可以通过异步函数构造器来创建 <code>async</code> 函数。但是需要注意的是 <code>AsyncFunction</code> 并不是一个全局对象。只能通过 <code>Object.getPrototypeOf()</code> 获得。同样，可以通过修改 <code>AsyncFunction</code> 的原型对象对所有 <code>AsyncFunction</code> 的实例提供自定义方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> AsyncFunction = <span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;).constructor;</span><br><span class="line"></span><br><span class="line">AsyncFunction.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Don\'t Panic!'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sleep = <span class="function"><span class="params">ms</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(resolve, ms));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> AsyncFunction(</span><br><span class="line">  <span class="string">'name'</span>,</span><br><span class="line">  <span class="string">'await sleep(1000); console.log("Hi " + name)'</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">foo(<span class="number">42</span>); <span class="comment">// Hi 42</span></span><br><span class="line"></span><br><span class="line">foo.say(); <span class="comment">// Don't Panic!</span></span><br></pre></td></tr></table></figure>
<h2 id="使用-async-functions-的注意事项"><a href="#使用-async-functions-的注意事项" class="headerlink" title="使用 async functions 的注意事项"></a>使用 async functions 的注意事项</h2><p>首先，需要注意的是 <code>async</code> 函数永远都会返回一个 <code>Promise</code> 对象，如果没有显式的指定返回值则会返回一个状态为 resolved 且值为 <code>undefined</code> 的 <code>Promise</code> 对象（抛出异常且未捕获除外）。</p>
<p>通常 <code>await</code> 会用来等待 <code>Promise</code> 对象。如果该值不是一个 <code>Promise</code> 对象(或 thenable 对象)，<code>await</code> 会把该值转换成状态为 resolved 的 <code>Promise</code> 对象，然后等待其处理结果。使用 <code>await</code> 等待一个被调用的方法，则会执行该方法并将其返回值转换为 <code>Promise</code> 对象，然后同样等待其处理结果。执行过程遇到的任何同步异常都会导致 <code>Promise</code> 对象的状态变成 rejected。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">someAsyncThing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">'oops'</span>;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'something happens'</span>); <span class="comment">// expression is unreachable!</span></span><br><span class="line">&#125;; <span class="comment">// Uncaught (in promise) oops</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = someAsyncThing();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo) <span class="comment">// Promise &#123;&lt;rejected&gt;: "oops"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> someOthersThings = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'You again!'</span>); <span class="comment">// You again!</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">someOthersThings();</span><br></pre></td></tr></table></figure>
<p>如上述代码，函数体内部同步抛出未捕获的异常，会导致 <code>async</code> 函数中断执行，并会立即返回一个状态为 rejected 的 <code>Promise</code> 对象。但并不会使得脚本挂起而导致后续代码无法执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">someAsyncThing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'oops'</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'something happens'</span>); <span class="comment">// expression is unreachable!</span></span><br><span class="line">&#125; <span class="comment">// Uncaught (in promise) oops</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = someAsyncThing();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// Promise &#123;&lt;pending&gt;&#125;</span></span><br><span class="line"></span><br><span class="line">foo.catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err)); <span class="comment">// oops</span></span><br></pre></td></tr></table></figure>
<p>如果任何一个 <code>await</code> 操作符后面的 <code>Promise</code> 对象变为 rejected 状态， <code>async</code> 函数同样会中断执行，立即返回一个状态为 pending 的 <code>Promise</code> 对象，并异步的将状态变为 rejected。</p>
<p>大多数情况下，从结果来看<code>return</code> 和 <code>return await</code> 没有什么明显的区别。虽然，根据各个 runtime  间的差异性，<code>return await</code> 可能会因为多创建一个中间对象（<code>Promise</code> 对象）而浪费少量的内存。但它们之间的差异性主要表现在嵌套于 <code>try...catch</code> 代码块中。下面是一个 <code>await</code>、<code>return</code>、<code>return await</code> 之前区别的例子。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// without return or await</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">rejectionWithoutReturnOrAwait</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'oops'</span>)); <span class="comment">// Uncaught (in promise) Error: oops</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Saved!'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> resultA = rejectionWithoutReturnOrAwait();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(resultA); <span class="comment">// Promise &#123;&lt;resolved&gt;: undefined&#125;</span></span><br><span class="line"></span><br><span class="line">resultA.catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err)); <span class="comment">// unreachable code</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// awaiting</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">rejectionWithAwait</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'oops'</span>)); <span class="comment">// Uncaught (in promise) Error: oops</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Saved!'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> resultB = rejectionWithAwait();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(resultB); <span class="comment">// Promise &#123;&lt;pending&gt;&#125;</span></span><br><span class="line"></span><br><span class="line">resultB.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res)); <span class="comment">// Saved!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// returning</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">rejectionWithReturn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'oops'</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Saved!'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> resultC = rejectionWithReturn();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(resultC); <span class="comment">// Promise &#123;&lt;pending&gt;&#125;</span></span><br><span class="line"></span><br><span class="line">resultC.catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err)); <span class="comment">// Error: oops</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// return-awaiting</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">rejectionWithReturnAndAwait</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'oops'</span>));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Saved!'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> resultD = rejectionWithReturnAndAwait();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(resultD); <span class="comment">// Promise &#123;&lt;pending&gt;&#125;</span></span><br><span class="line"></span><br><span class="line">resultD.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res)); <span class="comment">// Saved!</span></span><br></pre></td></tr></table></figure>
<h2 id="V8-引擎对异步函数的优化"><a href="#V8-引擎对异步函数的优化" class="headerlink" title="V8 引擎对异步函数的优化"></a>V8 引擎对异步函数的优化</h2><img src="/2018/11/11/dive-in-async/await-bug-node-8.svg">
<p>上图的代码分别展示了不同版本的 V8 引擎对 <code>await</code> 语句执行顺序的差异性。导致这一差异的主要原因是 <code>await p;</code> 这条语句。</p>
<p>简单的讲，Node.js 10 中的实现（V8 团队的 PR 被 merge 之前）是符合现行标准的，而 Node.js 8 中的实现并没有严格按照 <a href="https://tc39.github.io/ecma262/#sec-promise-resolve-functions" target="_blank" rel="noopener">Promise Resolve Functions</a> 中的第十三步执行。但是我们在 Chrome 72 以上的版本执行这个代码段，依然会得到和 Node.js 8 中一样的答案，是因为在最新版本的 V8 引擎，V8 团队为了提高 <code>async</code> 函数的执行效率，提出新的<a href="https://github.com/tc39/ecma262/pull/1250" target="_blank" rel="noopener">优化建议</a>并已经被 TC39 采纳。</p>
<p>它们之间到底有什么区别呢？我们将上图中的代码稍稍改进一下。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve();</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> p;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'after:await'</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'tick:a'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'tick:b'</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'tick:c'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Node.js 10:</span></span><br><span class="line"><span class="comment">// tick:a</span></span><br><span class="line"><span class="comment">// tick:b</span></span><br><span class="line"><span class="comment">// after:await</span></span><br><span class="line"><span class="comment">// tick:c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Chrome 73:</span></span><br><span class="line"><span class="comment">// after:await</span></span><br><span class="line"><span class="comment">// tick:a</span></span><br><span class="line"><span class="comment">// tick:b</span></span><br><span class="line"><span class="comment">// tick:c</span></span><br></pre></td></tr></table></figure>
<p>其中关键代码便是 <code>await p;</code>。而导致差异性的原因是因为 <code>p</code> 是一个 <code>Promise</code> 对象。<code>Promise</code> 构造器的 callback 内 <code>resolve(thenable)</code> 并不等于 <code>Promise.resolve(thenable)</code>。</p>
<p>依照现行（V8 团队的 PR 被 merge 之前，也就是 Node.js 10 里）规范，上述代码中的 IIFE 等价于：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      res(p);</span><br><span class="line">    &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'after:await'</span>);</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>其中执行 <code>res(p);</code> 这条语句的时，因为 <code>p</code> 是一个 <code>Promise</code> 对象，而 <code>Promise</code> 对象都是 thenable 对象。所以在执行 <code>res()</code>  之前，JavaScript 引擎会创建一个 MicroTask 去处理这个 thenable 对象，  在<a href="https://tc39.github.io/ecma262/#sec-promiseresolvethenablejob" target="_blank" rel="noopener">规范</a>中这个 MicroTask 被定义为 PromiseResolveThenableJob。PromiseResolveThenableJob 的执行过程中会调用 thenable 对象的 <code>then</code> 方法，而 <code>Promise</code> 对象的 <code>then</code> 方法也是一个 MicroTask，所以在 loop 中，这个过程增加了两次 MicroTick。若 thenable 对象的 then 方法是一个同步方法，则这个过程只会增加一次 MicroTick。</p>
<p>而在 Chrome 73 及未来版本的 Node.js 中，<code>res(p);</code> 这条语句等价于 <code>Promise.resolve(p)</code> 。即：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(p).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'after:await'</span>);</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>那这样做的好处是什么呢？显而易见，在代码执行过程中不需要再次创建用于包装的 <code>Promise</code> 对象，至少三次的 MicroTick 被优化到只有一个。如下图所示，这样做提高了 <code>async</code> 函数的性能。</p>
<img src="/2018/11/11/dive-in-async/await-benchmark-optimization.svg">
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://hackernoon.com/async-await-generators-promises-51f1a6ceede2" target="_blank" rel="noopener">Async-Await ≈ Generators + Promises</a></li>
<li><a href="https://jakearchibald.com/2017/await-vs-return-vs-return-await/" target="_blank" rel="noopener">await vs return vs return await</a></li>
<li><a href="https://v8.dev/blog/fast-async#await-under-the-hood" target="_blank" rel="noopener">Faster async functions and promises</a></li>
<li><a href="https://stackoverflow.com/questions/53894038/whats-the-difference-between-resolvethenable-and-resolvenon-thenable-object" target="_blank" rel="noopener">Difference between resolve(thenable) and resolve(‘non-thenable-object’)</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2018/11/03/class-field/" class="next">NEXT ></a></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-110485612-1",'auto');ga('send','pageview');</script></body></html>